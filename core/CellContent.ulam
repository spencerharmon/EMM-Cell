/**
  Base class for all emm-cell components that belong inside the membrane.

  \radius 2
  \author Spencer Harmon
  \license lgpl
 */
quark CellContent : QContent{
  Random r;
  SiteUtils su;
  AtomUtils au;
  EventWindow ew;
  typedef EventWindow.SiteNum SiteNum;
  typedef AtomUtils.Type ElementType;
  typedef WindowScanner.Category Category;
  typedef EventWindow.Symmetry Symmetry;
  
  virtual Void specialBehavior();
  virtual Void specialPhaseTwoBehavior(SiteNum sn);

  //used by genecopy stuff 
  virtual Bool invertSymmetry(){ return false; }
  virtual Bool disableCellMovement(){ return false; } 

  Void die(){
    Empty e;
    ew[0] = e.atomof;
  }

  SiteNum typeScan(ElementType t){
    SiteVisitorByType sv;
    WindowScanner ws;

    ws.resetCategories();
    Category cat = ws.allocateCategory();
    sv.setType(cat,t);

    ws.scan(sv);
    if(ws.getHits(cat) > 0u){
      return ws.getSiteNum(cat);
    }else{
      return 0u;
    }
  }

  Bool putInEmpty(Atom a){
    Empty e;
    ElementType tEmpty = au.getValidType(e);
    SiteNum emptySlot = typeScan(tEmpty);
    if(emptySlot > 0){
      ew[emptySlot] = a;
      return true;
    }else return false;
  }

  Void reproMetaSearch(){
    /*
    Check base layer and see if we're standing on a reprophaseone enzyme left by
    another cell.
    If we find it, create a reprophasetwo enzyme to let the rest of our cell know.
    We also have to copy the data from the EReproPhaseOne into EReproPhaseTwo.
    Delete the 'phase one' enzyme in the pase layer if we manage to create the
    'phase two' enzyme.
    Otherwise, leave it alone. Hopefully we can get it next time or some other
    cell contents will find it and succeed.
    */
    Atom a = su.getBase();
    if(a as EReproPhaseOne){
      EReproPhaseTwo rpt;
      for(Unsigned t = 0; t <= rpt.maxTrees; ++t){
        rpt.treeCopied[t] = a.treeCopied[t];
      }
      if(putInEmpty(rpt.atomof)){
        Empty e;
        su.setBase(e.atomof);
      }
    }
  }

  Void geneCopySearch(){
    Atom a = su.getBase();
    if(a as QGeneCopy){
      if(putInEmpty(a.atomof)){
        Empty e;
        su.setBase(e.atomof);
      }
    }
  }
  Symmetry opposite(Symmetry sym){
    if(sym < 4u){
      return (Symmetry) (sym + 4u);
    }else{
      return (Symmetry) (sym - 4u);
    }
  }

  Bool evaluateRuleSets(){
    specialBehavior();

    WindowScanner ws;
    SiteVisitorByType sv;

    Category cEDeath = ws.allocateCategory();
    Category cEReproPhaseOne = ws.allocateCategory();
    Category cEReproPhaseTwo = ws.allocateCategory();
    Category cESymmetry = ws.allocateCategory();

    EDeath aEDeath;
    EReproPhaseOne aEReproPhaseOne;
    EReproPhaseTwo aEReproPhaseTwo;
    ESymmetry aESymmetry;

    ElementType tEDeath = au.getValidType(aEDeath);
    ElementType tEReproPhaseOne = au.getValidType(aEReproPhaseOne);
    ElementType tEReproPhaseTwo = au.getValidType(aEReproPhaseTwo);
    ElementType tESymmetry = au.getValidType(aESymmetry);

    sv.setType(cEDeath, tEDeath);
    sv.setType(cEReproPhaseOne, tEReproPhaseOne);
    sv.setType(cEReproPhaseTwo, tEReproPhaseTwo);
    sv.setType(cESymmetry, tESymmetry);

    ws.scan(sv);

    if(ws.getHits(cEDeath) > 0u){
      die();
    }
    if(ws.getHits(cEReproPhaseOne) > 0u){
      reproMetaSearch();
    }
    if(ws.getHits(cEReproPhaseTwo) > 0u){
      geneCopySearch();
      specialPhaseTwoBehavior(ws.getSiteNum(cEReproPhaseTwo));
    }
    if(ws.getHits(cESymmetry) > 0u){
      Atom a = ew[ws.getSiteNum(cESymmetry)];
      if(a as ESymmetry){
        if(self.invertSymmetry()){
	  ew.changeSymmetry(opposite(a.sym));
	}else{
	  ew.changeSymmetry(a.sym);
	}
      }
    }
    if(!self.disableCellMovement()){
    //todo: I don't think they move yet...
    }
    return true;
  }
}