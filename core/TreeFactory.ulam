/**
  TreeFactory is a top-level, concrete class that handles the creation of random
  tree genes, especially as it relates to the Grow method.
  This is a central place for parameters and attributes about genes and their growth.
 */

quark TreeFactory{
  typedef EMMTypes.OperatorType OperatorType;
  typedef EMMTypes.TreeID TreeID;
  typedef EMMTypes.GeneID GeneID;
  typedef EMMTypes.ID ID;
  typedef EMMTypes.StoredValue StoredValue;
  typedef EventWindow.SiteNum SiteNum;

  DebugUtils du;
  Random r;

  constant Unsigned growOdds = 10u;

  Atom createRandomTerminator(TreeID t, GeneID g, TreeID new){
    du.print("Creating terminator, tree:");
    du.print(t);
    du.print("Creating terminator, gene:");
    du.print(g);
    //we have to keep track of the terminator types here.
    Unsigned terminatorTypes = 2; //zero-base?
    Unsigned roll = r.create(terminatorTypes);
    which(roll){
      case(0u):
      {
        Value v;
        v.treeID = t;
        v.geneID = g;
        v.value = (StoredValue) r.create(StoredValue.maxof);
	du.print(v);
        return v.atomof;
      }
      case(1u):
      {
        ComIn c;
        c.treeID = t;
        c.geneID = g;
	du.print(c);
        return c.atomof;
      }
      case(2u):
      {
        VarRef v;
        v.treeID = t;
        v.geneID = g;
        v.refID = new;
	du.print(v);
        return v.atomof;
      }
    }
    Empty e;
    return e.atomof;
  }

  Atom createRandomOperator(TreeID t, GeneID g, GeneID t0, GeneID t1){
    du.print("Creating operator, tree:");
    du.print(t);
    du.print("Creating operator, gene:");
    du.print(g);
    OperatorGene og;
    og.treeID = t;
    og.geneID = g;
    og.tree0 = t0;
    og.tree1 = t1;
    OperatorType max = OperatorType.maxof;
    og.op = (OperatorType) r.create(max);
    du.print(og);
    return og.atomof;
  }

  Atom createRandomRoot(TreeID t){
    Root ro;
    ro.treeID = t;
    //  is this safe to assume, or should the calling class
    // provive IDs based on ERootInformation process?
    ro.tree0 = (GeneID) 0;
    ro.tree1 = (GeneID) 1;
    ro.op = (OperatorType) r.create(OperatorType.maxof);
    return ro.atomof;
  }

  Atom createRandomID(){
    Identifier i;
    i.id = (ID) r.create(ID.maxof);
    return i.atomof;
  }

  //roughly grow as-in grow vs full.
  //full is not yet implemented since 
  //tree depth can't be derrived from GeneIDs.
  Atom grow(TreeID t, GeneID g, GeneID t0, GeneID t1, TreeID new){
    if(r.oneIn(2u)){
      return createRandomTerminator(t, g, new);
    }else{
      return createRandomOperator(t, g, t0, t1);
    }
    Empty e;
    return e.atomof;
  }
}