8/22/2019
 - I thought it was clever to use a transient rather than pass an Atom& around, but since a transient full of 13 atoms can't be a data member (obviously), I'm going to have to plumb this transient down to every special behavior function in order to use it. Oh well, at least at the end of it, I can carry around an unlimited amount of state without further toil and bake in accessor and priority logic. Right?
  - Looks like the 13 atom data size isn't a problem (at least it compiles like this). I need to plumb it down with the right pointer symbols to EGrow where it's writing to ew[0] and stop this nonsense.
  - The Naming of Things: Caught myself trying to do some ruler-of-the-event stuff by keeping track of the state of all of the sites. It was about to break ew[n] access altogether. So, instead of FinalEWState, we have the humble TransitionSelf. Once we state for our intent that keeping track of who ew[0] is supposed to be at the end of the event, we have one thing to do well. It feels silly now to have not gone ahead with Dave's advice to pass around an Atom&, but maybe I figured out I can take care of ew.swap(0,n) at the end of the event along with plain old ew[0] updates. I could get transition + move for free, which is neat and maybe I won't have to worry about stale atom refs with tf.swap(). I also want a priority system, but that'll have to come later.
  - It's a crucial point that TransitionSelf doesn't change ew[0] unless it's been requested. Bad things happen otherwise.
  - I need to make a color scheme for these atoms. What to do?
    - Root: Brown
    - OperatorGene: pink
    - ComIn: light Purple
    - VarRef: light Blue
    - Value: Blue
    - EGrow: light green
    - ERequest: gray
    - EResponse: Black
    - ERootInformation: Light brown
    - ETreeGeneInfo: orange
    - Identifier: red
  - all the colors worked except for egrow. fine for now
  - I think I should get this slow fork bomb under control next. EGrow is making operators before it gets good info for child geneIDs from ETreeGeneInfo. I think EGrow can be way less aggressive and just wait until conditions are perfect (i.e. plenty of info to proceed).

8/24/2019
 - What's working: enzyme density is reasonable for now (though with more enzyme types and fewer matches, this could be a problem down the road). Gene growth is successful, and the respose system seems to work ok in smaller cells. problems occur when a gene is too far away for an ERequest to make it to the target gene in time, eventually leading to duplicates.
 - What's not working: Things are still looking grim in terms of uncontrolled cell growth, but at least grows are kept in check and insane numbers of non-root tree genes aren't getting created. The next big thing is going to be keeping the enzyme numbers down. Density looks good, but they expand the cell more than needed by the genes.
 - Idea: enzymes die when they're next to an InnerMembrane. The genes themselves act as a sort of scaffold that the enzymes move around in.
 -Failed. young cells can't keep ERequest alive long enough to start growing.
 - next idea: enzymes die when they can't see genes.
 - Promising. It still took a while for an ERequest to survive long enough to grow, but the resulting cell was of reasonable size for the data contained, the genes themselves were stable and persistent, and growth stopped when all of the requested genes already existed. Logs say the first EGrow was created at 10139AEPS. I'm not sure if it waited until it smashed into the edge of the universe to strat growing. it should work without finding an edge..
 - note: there is definitely some anisotropy going on here. I hope it's just the chewing gum and sticks I put in place instead of a movement system based on genetics.
 -I know I need to add the OperatorUtils.doOperate() method to the special behavior in OperatorGene soon, which should trigger growth beyond the second layer of the equation tree, but I have to get ERequest to get proper tree0/tree1 for EGrow before this. I'm hoping to avoid multiple references to the same gene right now (except VarRef), which means ETreeGeneInfo needs to be pretty fast and accurate.
 - next step: debug the ETreeGeneInfo. make sure that one is getting created for all of the trees.
   then, debug the newgene/secondnewgene methods in EGrow
 - ETreeGeneInfo exists for the target tree and is accurate. Debug egrow.
 - Got expected results from egrow.
 - ETreeGeneInfo needs to log ERequests as genes.
 - after that, I think we need to build in a churning/clustering behavior other than this non-funtional anisotropic diffusion that's happening now.

8/25/2019
 - Actually any QGrow could be a gene. ETreeGeneInfo can log them all. What if you log an EGrow that eventually fails? I think something needs to come along and kill all of the info atoms occasionally to get a new read. Info atoms never have enough information to transition a geneid or treeid from true to false, so starting over is the next best thing.
 - problem: selecting genes sequentially leads to a race condition, with EGrow trying to get the next available genes even if another operator is already referencing them. This should be helped in part by considering all QGrow atoms as a found GeneID.
 - possible solution: don't select a GeneID sequentially. Pick one at random, if it's available, that's the gene, otherwise fail. Pretty sure this sould make it progressively harder to get a gene. Maybe a combination of these strategies. Randomly select a geneID and if it's taken, step through the rest of the list to find one that's available. Best of both worlds? we'll see. 
 - thought: init can create a ERootInformation so gene information is ready for the first EGrow. 
 - Enzyme/gene interactions are looking pretty good, but things could be moving faster. I want to try shortening the Enzyme lifespan again. Should speed up end-of-life enzyme processeses like ERequest -> EGrow and help clear out unneccessary Enzymes more quickly.
 - That was a spectacular difference. I think the faster enzymes are much preferred. Grows are created a little quickly right now, but a slight clustering bias should help the ERequests find their target. If it's still too much, we can twiddle with the odds of ERequest transitioning to EGrow.

9/7/2019
 - I've been thinking of the concept of clustering inside a membrane in the mfm afk for the past couple of weeks. There are a couple of things we know:
    1. genes, enzymes, and other cell content need to move around to propagate information within the cell.
    2. the larger and more spread-out a cell is, the less likely it is that a cell content will come in contact with is counterparts to complete its process.
    3. This has disasterous effects on the longevity of genes since an operator (Root or OperatorGene) can initiate a grow process for a gene that is simply too far away for a eresponse to make it back to the requestor.
    4. a sufficiently spread-out cell can fissure, causing non-viable tree fragments.
    5. clustering things together means eliminating empty sites between them
 - I've thought of some potentially elaborate ways to sole this, from radius 4 cluster atoms that bring together genes or cell contents, to atoms that move in some spiral pattern to attempt to find or establish a center, dragging other cell components with it, but all of this seems like a lot of engineering for potentially little reward. As I sit here, I'm rethiking how cell-content movement logic should work. The current cell contents behavior to solve point 1 above is to randomly diffuse (though I think anisotropies do exist here, that's beside the point for now) by swapping with an empty atom one site away in a randomly chosen direction. This necessarilly introduces empty space between atoms we want to keep together. So, let's make some new rules about how cellcontent moves within a cell:
   Churning:
     - If the entire event window is cell content or empty, swap with any cell content.
   Directional Movement:
     - If an ESymmetry is found, and the site immediately in front (ew[1] for the indicated symmetry) is empty, swap with it.
   Remove bubbles:
     - If no ESymmetry is found, swap with a random empty site in the event window unless we see an innermembrane. (fill in gaps)
   Surface behavior:
     - If an InnerMembrane is found, only curning and directional movement may be performed.

9/8/2019
  - Without having written any code for it yet, I'm most concerned with the "remove bubbles" process, since it relies on the idea that the bias induced by seeing an inner membrane (being on the surface) is sufficient to eventually move all of the empty atoms to the surface and bring cell contents together.
  - I haven't written an ESymmetry or a symmetry root yet in this iteration, but these dynamics need to be accounted for to consider anything a wholistic solution to inner-cell clustering. I've taken to the idea of bubbles in a similar sense to the classic physics analogy between electron holes and their role in circuits and bubbles moving through liquids in a tube. In a similar fashion, Empty atoms will appear to move in the opposite directon of that indicated by ESymmetry through the cell contents cluster.
  - By comparison, when there aren't any ESymmetry enzymes in the cell, bubbles will appear to move by random diffusion with a radius of 2 until they reach the surface, where they'll be left alone by surface cell contents. (Until an ESymmetry is created.)
  - Since cell contents that are over 2 sites away from the membrane won't have any indication of this fact, random bubbles can be introduced at this layer, which may form a kind of foam or vapor pressure at the surface, which should help for reactions that require empty sites.
  - As long as we keep the behavior where enzymes die when adjacent to the membrane, the denisty of this foam or vapor pressure on the surface may be related to the ratio of enzymes to genes in the cell.
  - Enough speculating. Time to write some code. I considered that this logic might be well-suited to SPLAT, but I think I'm more comfortable leveraging a WindowScanner in Ulam for now.
  