= quark QOuterMembrane isa QMembrane

== Data Members
u typedef EMMTypes.ID ID;
u typedef EMMTypes.StoredValue StoredValue;
u XTimer(2, 3, 1) dataAge;
u virtual StoredValue & getComOut();
u virtual Bool & getBonding();

== Rule2 (com in)
given @ isa QOuterMembrane
given i isa QInnerMembrane
vote e isa Empty
vote n isa QInnerMembrane {
.  Atom myIM = ew[$i.$winsn];
.  if ($curatom as QInnerMembrane){
.    if (myIM as QInnerMembrane) {
.       if($curatom.getID() != myIM.getID()){
.         return (Votes) 1;
.       }
.     }
.   }
.   return (Votes) 0;
. }
given m isa QOuterMembrane
check @ {
.   if($n.$nvotes > 0u){
.     Atom neighborCell = ew[$n.$winsn];
.     Atom myIM = ew[$i.$winsn];
.     if (myIM as QInnerMembrane) {
.       if (neighborCell as QInnerMembrane) {
.         if(neighborCell.getID() != myIM.getID() && $e.$nvotes > 0u){
.           Atom m = ew[$m.$winsn];
.           if (m as QOuterMembrane){
.             EComIn eci;
.             eci.value = m.getComOut();
.             ew[$e.$winsn] = eci.atomof;
.           }
.         }
.       }
.     }
.   }
.   return false;
. }

 nm@ie   -> .....

== Rule3 (propagate com out)
vote o isa QOuterMembrane {
.   Atom slf = ew[0];
.   if (slf as QOuterMembrane){
.     if($self.dataAge.time > slf.dataAge.time){
.       return (Votes) 1;
.     }else{
.       return (Votes) 0;
.     }
.   }
. }

check @ {
.   Atom & slf = ew[0];
.   if (slf as QOuterMembrane){
.     if(slf.dataAge.time == 3u && $o.$nvotes > 0u){
.       Atom neighbor = ew[$o.$winsn];
.       if (neighbor as QOuterMembrane) {
.         typedef EMMTypes.StoredValue StoredValue;
.         StoredValue & comout = slf.getComOut();
.         comout = neighbor.getComOut();
.         slf.dataAge.time = neighbor.dataAge.time;
.       }
.     }
.   }   
.   return false;
. }

 ooo    ...
 o@o -> ...
 ooo    ...


== Rule 4 (increment data age timer)
check @ {
.   Atom & slf = ew[0];
.   if (slf as QOuterMembrane){
.     slf.dataAge.count();
.   }
.   return false;
. }

 @ -> .

== Rule 5 (scan for bonding)

check @ {
.   Atom & slf = ew[0];
.   if (slf as QOuterMembrane){
.     Bool & gb = slf.getBonding();
.     gb = false;
.  
.     if ($i.$nvotes > 0u){
.       Atom im = ew[$i.$winsn];
.       if (im as QInnerMembrane){
.         if (im.getBonding()){
.           gb = true;
.         }
.       }
.     }
.   }
.   return false;
. }

  i      .
 i@i -> ...
  i      .
  

#== Rule (must have two neighbors)
#vote O {
#.   Atom slf = ew[0];
#.   if (slf as QOuterMembrane){
#.     Atom o = ew[$cursn];
#.     if (o as QOuterMembrane){
#.       if(o.getID() == slf.getID()){
#.         return 1u;
#.       }else{
#.         return 0u;
#.       }
#.     }
#.   }
#.   return 0u;
#. }
#check @ {
#.   DebugUtils du;
#.   du.print("Votes:");
#.   du.print($O.$nvotes);
#.   if ($O.$nvotes == 1u){
#.     MembraneUtils mu;
#.     mu.membraneDebugPrint();
#.   }else if ($O.$nvotes >= 2u){
#.     return false;
#.   }else{
#.     du.print("<2 neighbors. Would have died..");
## .     du.print("OM died. Needs two neighbors.");
## #  todo: This is probably not ideal. Maybe splattr instance needs a transitionself? Anyway..
## .     Empty e;
## .     ew[0] = e;
## .     return true;
#.   }
#. }
#
#
#
#  OOO      ...
#  O@O  ->  ...
#  OOO      ...
#

== Rules OMB growth
given @ isa QOuterMembrane
given i isa QInnerMembrane
given o isa QOuterMembrane

let q = o|i
given p isa InnerMembraneParentBond
given c isa ChildInnerMembrane
given e : true      // Allow dead sites
vote  e isa Empty   // Count empty sites
check e : $nvotes*3u>=$nsites*2u 
check f : random.oddsOf($nvotes,3)
change i {
.   ew[$cursn] = ew[$i.$picksn];
. }
change c {
.   ew[$cursn] = ew[$c.$picksn];
. }

change P {
.   ew[$cursn] = ew[$p.$picksn];
. }

let a = e|p
let x = a|o

  apqqf       .....
 appoqff     ..@....
 apo@iff ->  ...i...     # Run out
 apoiiff     .......

    xo        ..
   _pocf     P@...
   _p@cf  -> P@c..       # Break out
   _pocf     P@...
    xo        ..

== Rules: OM management (mostly growing)
given @ isa QOuterMembrane
given i isa QInnerMembrane
given o isa QOuterMembrane

let q = o|i
given n : !($curatom is QInnerMembrane)

given e : true      // Allow dead sites
vote  e isa Empty   // Count empty sites
check e : $nvotes*3u>=$nsites*2u 

vote  f isa QContent // Count up content
check f : random.oddsOf($nvotes,3)

change o {
.   ew[$cursn] = ew[$o.$picksn];
. }

change i {
.   ew[$cursn] = ew[$i.$picksn];
. }

given E isa Empty

vote g isa EggShell

# Self-stabilization rules

  i_       .@
  i@   ->  ..    # Square off (complete outer membrane)

  nnn      ...
  n@n  ->  ._.   # Die off (eliminate isolated outer membrane)
  nnn      ...

  iii      ...
  i@i  ->  .i.   # Turn in (eliminate surrounded outer membrane)
  iii      ...

#probably extraneous
#  @_   ->  @@    # fix corner errors
#  io       i@


# disable growth near egg
  g        .
 g@g  ->  ...
  g        .




# Growth rules
 eeEoqff     ..@....
 eeo@iff ->  ...i...     # Run out
 eeoiiff     .......

    eo        ..
    _oif      @...
    _@if  ->  @i..       # Break out
    _oif      @...
    eo        ..


      ff       ..
    qiif     ....
    o@if  -> .i..        # Punch out
    qiif     ....
      ff       ..

let r = o|E

    roqf          @...
    o@if    ->    .i..   # Cave out
    qiif          ....
    ffff          ....

# OuterMembrane topology changing rules

   fffff          .....
  iiiiiii        .......
 oooo@oooo  ->  ....i....  # Fusion
  iiiiiii        .......
   fffff          .....


